/**
 * This object is used to detect the gate object.
 *
 * @author Jean-Sebastien Dery
 * @author Frederic Lafrance
 * @author Renaud Dagenais
 * @author Haris Haidary
 */

#include "Gate.h"

const std::string COLOR_THRESH_WINDOW = "color_thresh_window";
const std::string TRACKBARS_WINDOW = "trackbars_window";

float centimetersPerPixel;

cv::Point centerOfCurrentFrame;

/**
 * Constructor.
 */
Gate::Gate() {

	ROS_INFO("%s", (std::string(__PRETTY_FUNCTION__) + ":: a Gate object was instantiated.").c_str());

	ros::NodeHandle nodeHandle;
	nodeHandle.param<bool>("is_using_helper_windows", isUsingHelperWindows, false);

if (isUsingHelperWindows == 1) {
	cv::namedWindow(COLOR_THRESH_WINDOW, CV_WINDOW_KEEPRATIO);
	cv::namedWindow(TRACKBARS_WINDOW, CV_WINDOW_KEEPRATIO);

	cv::createTrackbar("start_hsv_hue_threshold", TRACKBARS_WINDOW, &start_hsv_hue_threshold, MAX_HSV_VALUE);
	cv::createTrackbar("end_hsv_hue_threshold", TRACKBARS_WINDOW, &end_hsv_hue_threshold, MAX_HSV_VALUE);
	cv::createTrackbar("start_hsv_value_threshold", TRACKBARS_WINDOW, &start_hsv_value_threshold, MAX_HSV_VALUE);
	cv::createTrackbar("end_hsv_value_threshold", TRACKBARS_WINDOW, &end_hsv_value_threshold, MAX_HSV_VALUE);
	cv::createTrackbar("gate_ratio_error", TRACKBARS_WINDOW, &gate_ratio_error, MAX_HSV_VALUE);
	cv::createTrackbar("max_number_points", TRACKBARS_WINDOW, &max_number_points, MAX_HSV_VALUE);
	cv::createTrackbar("polygon_approximation_threshold", TRACKBARS_WINDOW, &polygon_approximation_threshold, MAX_HSV_VALUE);
}
}

/**
 * Destructor.
 */
Gate::~Gate() {
if (isUsingHelperWindows == 1) {
	cv::destroyWindow(COLOR_THRESH_WINDOW);
	cv::destroyWindow(TRACKBARS_WINDOW);
}
}

/**
 * Applies the necessary filters to the current frame, checks if the door
 * object is present and, if it is, extracts the necessary information.
 * @param currentFrame Current camera frame
 * @return If the door is present, it returns a pointer to an ObjectData
 *  which contains the information gathered on the door. If the door is
 *  not present in the current frame, it returns the zero pointer (NULL).
 */
std::vector<computer_vision::VisibleObjectData*> Gate::retrieveObjectData(cv::Mat& currentFrame) {
	std::vector<computer_vision::VisibleObjectData*> messagesToReturn;
	m_isVisible = false;

	applyFilter(currentFrame);

	if (m_isVisible) {
		computer_vision::VisibleObjectData* visibleObjectData = new computer_vision::VisibleObjectData();		

		// Return gathered data to caller
		visibleObjectData->object_type = visibleObjectData->DOOR;
		visibleObjectData->yaw_angle = m_yawAngle;
		visibleObjectData->pitch_angle = 0.0; //Pitch angle is not used anymore
		visibleObjectData->x_distance = m_xDistance;
		visibleObjectData->y_distance = m_yDistance;
		visibleObjectData->z_distance = m_zDistance;

		messagesToReturn.push_back(visibleObjectData);

//		ROS_INFO("%s", "Added a ROS message in the list of messages to return to the cv node.");
	}

//	ROS_INFO("%s", ("About to return the ROS message list to the cv node that contains " + boost::lexical_cast<std::string>(messagesToReturn.size()) + " element(s).").c_str());

	return (messagesToReturn);
}

/**
 * Function that will apply filter on the image so we can detect the door.
 *
 * @param currentFrame The frame to which we need to apply the filters.
 */
void Gate::applyFilter(cv::Mat& currentFrame) {
	HSV_ENDING_FILTER_RANGE = cv::Scalar(end_hsv_hue_threshold, 255, end_hsv_value_threshold);
	HSV_STARTING_FILTER_RANGE = cv::Scalar(start_hsv_hue_threshold, 0, start_hsv_value_threshold);

	std::vector<PoleCandidate> potentialMatchRectangles;
	centerOfCurrentFrame.x = currentFrame.cols/2;
	centerOfCurrentFrame.y = currentFrame.rows/2;

	// Converts the current frame to HSV in order to ease color filtering (with varying brightness).
	cv::Mat currentFrameInHSV = convertFromBGRXToHSV(currentFrame);

	// Apply a Gaussian Blur filter to regularise the pixels from the camera image.
	// This is done in a try to reduce the noise generated by the sensor of the camera.
	cv::GaussianBlur(currentFrameInHSV, currentFrameInHSV, cv::Size(KERNEL_SIZE, KERNEL_SIZE), 0, 0);

	// Finds all the contours in the image and store them in a vector containing vectors of points.
	std::vector<std::vector<cv::Point> > detectedContours = findContoursFromHSVFrame(currentFrameInHSV);

	// Goes through all the identified shapes for a first filtering.
	for (int rectangleID = 0; rectangleID < detectedContours.size(); rectangleID++) {

		// Finds a rotated rectangle that defines the contour of the object.
		std::vector<cv::Point> contour = detectedContours.at(rectangleID);
		PoleCandidate pole = findRectangleForContour(contour);

		bool passesFilter = false;
		// Filter the rectangles based on several parameters (acceptable ratio, angle error, etc.)
		if ((pole.h / pole.w) > MIN_GATE_RATIO && contour.size() >= 4 &&
			std::abs(pole.rectangleAngleDeg - DESIRED_ANGLE_OF_RECT) < ANGLE_RECT_ERROR ) {

			passesFilter = true;
			computePolarCoordinates(pole, centerOfCurrentFrame, currentFrame.size().height);
			potentialMatchRectangles.push_back(pole);

			//Draw contour points
			drawPointsOfContour(currentFrame, contour, GREEN_BGRX);			
		} else {
			drawPointsOfContour(currentFrame, contour, RED_BGRX);
		}

		writePoleCandidateInfo(pole, passesFilter, currentFrame);
	}

	int numberOfPotentialMatch = potentialMatchRectangles.size();
	//  Here I assume that the two rectangles that I have are the orange cylinders of the gate.
	if (numberOfPotentialMatch == 2) {
		m_isVisible = true;

		PoleCandidate& p1 = potentialMatchRectangles[0];
		PoleCandidate& p2 = potentialMatchRectangles[1];

		handleTwoVisiblePoles(p1, p2, centerOfCurrentFrame);
		

		cv::Point centerPoint((p1.center.x + p2.center.x) / 2,
					(p1.center.y + p2.center.y) / 2);
		//Draw the point on-screen
		cv::circle(currentFrame, centerPoint, 30, GREEN_BGRX, 2, 5);
		cv::line(currentFrame, p1.center, p2.center, WHITE_BGRX, 1, CV_AA); 
	}
	
	//Center of image circle
	cv::circle(currentFrame, centerOfCurrentFrame, 5, MAUVE_BGRX, 2, 5);
}

void Gate::handleTwoVisiblePoles(PoleCandidate& p1, PoleCandidate& p2, cv::Point centerOfCurrentFrame) {
	
	PoleCandidate& closest = (p1.dist < p2.dist) ? p1 : p2;
	PoleCandidate& farthest = (p1.dist < p2.dist) ? p2 : p1;

	/* Use law of sines to compute far angle */	

	//If both angles are on the same side of the image, the robot angle is the largest minus the smallest
	float sumAngles = 0.f;
	if( std::max(p1.center.x, p2.center.x) < centerOfCurrentFrame.x ||
	    std::min(p1.center.x, p2.center.x) > centerOfCurrentFrame.x )
		sumAngles = std::max(p1.objectAngleRad, p2.objectAngleRad) -
				std::min(p1.objectAngleRad, p2.objectAngleRad);
	else //Otherwise it's the normal sum
		sumAngles = p1.objectAngleRad + p2.objectAngleRad;

	// 90 - angleFar- farthest.objectAngle
	float sinFar = sin(sumAngles) * closest.dist / GATE_WIDTH;
	m_yawAngle = (3.141592654 / 2.0) - asin(sinFar) - farthest.objectAngleRad;

	if(closest.center.x < farthest.center.x)
		m_yawAngle = -m_yawAngle;

	//Get the x,y coordinates of the gate in the world
	float x1 = cos(p1.objectAngleRad) * p1.dist, x2 = cos(p2.objectAngleRad) * p2.dist;
	float y1 = sin(p1.objectAngleRad) * p1.dist, y2 = sin(p2.objectAngleRad) * p2.dist;

	if(p1.center.x - centerOfCurrentFrame.x < 0)
		y1 = -y1;

	if(p2.center.x - centerOfCurrentFrame.x < 0)
		y2 = -y2;

	m_xDistance = (x1 + x2) / 2.0;
	m_yDistance = (y1 + y2) / 2.0;

	int centerY = (p1.center.y + p2.center.y) / 2;
	float avgMPerPx = ((DOOR_REAL_HEIGHT / p1.h) + (DOOR_REAL_HEIGHT / p2.h)) / 2.0;
	m_zDistance = (centerY - centerOfCurrentFrame.y) * avgMPerPx;

//	std::cout << "[DEBUG] Gate found: <" << m_xDistance << "," << m_yDistance << "," << m_zDistance << "> yaw " <<
//			m_yawAngle * 180.0 / 3.141592654 << std::endl;
}

/**
 * Based on a contour, return a partially filled pole candidate structure that contains information about the rectangle
 * bounding the contour.
 *
 * @param contour A contour of points in the image
 * @return A pole candidate. The objectAngleRad and dist fields are NOT valid.
 */
Gate::PoleCandidate Gate::findRectangleForContour(std::vector<cv::Point>& contour) {
	PoleCandidate ret;	


	cv::RotatedRect boundingRect = cv::minAreaRect(cv::Mat(contour));
	// Determining the Width, Height and Ratio of the rotated rectangle.
	// Here by convention the height is the longest side of the rectangle.
	ret.w = (boundingRect.size.width < boundingRect.size.height) ? 
			boundingRect.size.width : boundingRect.size.height;
	ret.h = (boundingRect.size.width < boundingRect.size.height) ? 
			boundingRect.size.height : boundingRect.size.width;

	ret.center = boundingRect.center;

	/* Calculate the angle of the rectangle. It is in interval [0, 180) and
	works as expected (i.e. rectangle on its side has angle 0, rectangle upright has
	angle 90) */
	cv::Point2f vertices[4];
	boundingRect.points(vertices);
	cv::Point2f p = vertices[0], q = vertices[1];
	cv::Point2f diff = p - q;
	float distanceFirstPoints = sqrt(diff.x * diff.x + diff.y * diff.y);
	//Check whether the two points we have form a width or a height.
	if(std::abs(distanceFirstPoints - ret.w) < std::abs(distanceFirstPoints - ret.h)) {
		p = q;
		q = vertices[2];
	}

	float opp = std::abs(p.y - q.y); //Want positive opposite side value
	//Get signed adjacent value (it's the highest point minus the lowest point)
	float adj = p.x - q.x;
	if(q.y < p.y)
		adj = -adj;

	float rectangleAngle = atan(opp / adj) * 180.0 / 3.141592654;
	if(rectangleAngle < 0)
		rectangleAngle = 180 + rectangleAngle;

	ret.rectangleAngleDeg = rectangleAngle;
	return ret;
}

/**
 * Based on a pole candidate, calculate its distance and angle in the world.
 */
void Gate::computePolarCoordinates(PoleCandidate& pole, cv::Point frameCenter, float frameHeight) {
	/* First approximation using the canonical formula */
	float approximateDistanceWithObject = (FOCAL_LENGTH * DOOR_REAL_HEIGHT * frameHeight) / 
							(pole.h * CAMERA_SENSOR_HEIGHT);

	/* We correct this distance, because it is only valid if the object is close to the center of the screen */
	float mPerPxAtObject = DOOR_REAL_HEIGHT / pole.h;
	float yMOffset = std::abs(frameCenter.x - pole.center.x) * mPerPxAtObject;
	pole.objectAngleRad = atan(yMOffset / approximateDistanceWithObject);
	pole.dist = approximateDistanceWithObject / cos(pole.objectAngleRad);
}

/**
 * Finds all contours (based on a HSV range) from an HSV frame and returns the cloud of points determining the contour.
 *
 * @param frameInHSV The frame in HSV color space.
 * @return The std::vector of std::vector of points containing the clouds of all contours in the image.
 */
std::vector<std::vector<cv::Point> > Gate::findContoursFromHSVFrame(const cv::Mat& frameInHSV) {

	// Creates the Mat object that will contain the filtered image (inRange HSV).
	cv::Mat inRangeHSVFrame;
	// Generates a new Mat object that only contains a certain range of HSV values.
	// Don't forget that we are not using BGRX, but the HSV color space.
	cv::inRange(frameInHSV, HSV_STARTING_FILTER_RANGE, HSV_ENDING_FILTER_RANGE, inRangeHSVFrame);

if (isUsingHelperWindows == 1) {
	cv::imshow(COLOR_THRESH_WINDOW, inRangeHSVFrame);
}

	// Finds the contours in the images.
	cv::Mat inRangeFrame = inRangeHSVFrame.clone();
	// So this vector will contain vectors of points that will form shapes in the image.
	std::vector<std::vector<cv::Point> > detectedContours;
	cv::findContours(inRangeHSVFrame, detectedContours, CV_RETR_CCOMP,
			CV_CHAIN_APPROX_SIMPLE);

	return (detectedContours);
}

/**
 * Draw information about a pole candidate on the frame.
 *
 */
void Gate::writePoleCandidateInfo(PoleCandidate& pole, bool passedFilter, cv::Mat& currentFrame) {

	if(passedFilter) {
		putText(currentFrame, "Distance=" + boost::lexical_cast<std::string>(pole.dist),
			cv::Point(pole.center.x, pole.center.y + 30),
			cv::FONT_HERSHEY_COMPLEX_SMALL, 0.4, WHITE_BGRX, 1,
			CV_AA);
		putText(currentFrame, "ObjectAngle=" + boost::lexical_cast<std::string>(pole.objectAngleRad * 180.0 / 3.141592654),
			cv::Point(pole.center.x, pole.center.y + 40),
			cv::FONT_HERSHEY_COMPLEX_SMALL, 0.4, WHITE_BGRX, 1,
			CV_AA);
	}

	putText(currentFrame, "Width=" + boost::lexical_cast<std::string>(pole.w),
		cv::Point(pole.center.x, pole.center.y),
		cv::FONT_HERSHEY_COMPLEX_SMALL, 0.4, WHITE_BGRX, 1,
		CV_AA);
	putText(currentFrame, "Height=" + boost::lexical_cast<std::string>(pole.h),
		cv::Point(pole.center.x, pole.center.y + 10),
		cv::FONT_HERSHEY_COMPLEX_SMALL, 0.4, WHITE_BGRX, 1,
		CV_AA);
	putText(currentFrame, "RectangleAngle=" + boost::lexical_cast<std::string>(pole.rectangleAngleDeg),
		cv::Point(pole.center.x, pole.center.y + 20),
		cv::FONT_HERSHEY_COMPLEX_SMALL, 0.4, WHITE_BGRX, 1,
		CV_AA);

}

/**
 * Draws the points defining a contour.
 *
 * @param frame The cv::Mat object on which the points will be drawn.
 * @param contour The vector containing the points to be drawn.
 */
void Gate::drawPointsOfContour(cv::Mat& frame, std::vector<cv::Point> contour, cv::Scalar COLOR) {
	// Draw each single point that forms the polygon.
	for (int j = 0; j < contour.size(); j++) {
		cv::Point singlePoint = contour.at(j);
		rectangle(frame, singlePoint, singlePoint, COLOR, 8, 8);
	}
}
